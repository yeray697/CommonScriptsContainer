name: .NET Core Desktop

on:
  push:
    #branches: [ "feature/3.0" ]
    branches: [ "feature/46/fix_build" ]

jobs:
  check_version_changed:
    runs-on: windows-latest 
    outputs:
      status: ${{ steps.check_version_changed.outputs.status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
          
      - name: Has Version changed?
        id: check_version_changed
        run: |
          $appCsProj = ""
          $regex = "([-+])\s*<AssemblyVersion>(.*)<\/AssemblyVersion>"

          $result = "skip"

          $regexMatches = git show --unified=0 -- $appCsProj | Select-String $regex -AllMatches | 
              ForEach-Object {$_.Matches}

          if ($regexMatches.Length -eq 2) {
              Write-Host "AssemblyVersion was modified"
              Write-Host "Checking if versions are different..."
              $firstSignFound = $regexMatches[0].Groups[1].Value
              $firstVersionFound = $regexMatches[0].Groups[2].Value
              $secondSignFound = $regexMatches[1].Groups[1].Value
              $secondVersionFound = $regexMatches[1].Groups[2].Value

              switch ($firstSignFound) {
                  "-" { $prevVersion = $firstVersionFound; Break; }
                  "+" { $newVersion = $firstVersionFound; Break; }
              }

              switch ($secondSignFound) {
                  "-" { $prevVersion = $secondVersionFound; Break; }
                  "+" { $newVersion = $secondVersionFound; Break; }
              }

              if (!$prevVersion) {
                  throw "PrevVersion was not populated"
              }

              if (!$newVersion) {
                  throw "NewVersion was not populated"
              }
              
              if ($prevVersion -eq $newVersion) {
                  Write-Host "AssemblyVersion has not changed"
              }
              else {
                  Write-Host "Different AssemblyVersion"
                  $result = "continue"
              }
              Write-Host "Previous Version: $prevVersion"
              Write-Host "New Version: $newVersion"

          }
          elseif ($regexMatches.Length -ne 0) {
              throw "Not the expected number of matches: $($regexMatches.Length)"
          }
          else {
              Write-Host "AssemblyVersion not modified"
          }
          echo "status=$result >> $env:GITHUB_OUTPUT"

  release:
    runs-on: windows-latest 
    needs: check_version_changed
    if: needs.check_version_changed.outputs.status == 'continue'
    env:
      App_Project_Path: Library\App\App.csproj
      App_PublishProfile_Path: Library\App\Properties\PublishProfiles\ProjectBuild.pubxml
      Inno_Setup_Path: ./Deployment/Setup.iss
      Inno_Setup_Tmp_Path: ./Deployment/Setup.tmp.iss
      Configuration: Release
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Install .NET Core
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x
        
    - name: Get App version
      id: get_version
      run: echo "version=$(([Xml] (Get-Content $env:App_Project_Path)).Project.PropertyGroup.AssemblyVersion)" >> $env:GITHUB_OUTPUT
      
    - name: Create the app package
      run: dotnet publish $env:App_Project_Path -c $env:Configuration /p:PublishProfile=$env:App_PublishProfile_Path

    - name: Create Zip Archive
      run: Compress-Archive -Path ./Library/App/Build/* -DestinationPath ./app-publish.zip
      
    - name: Prepare Inno Setup file
      id: prepare_inno_setup
      run: |
        $innoVariables = "#define AppMode ""${{ env.configuration }}""`r`n#define ApplicationVersion ""${{ steps.get_version.outputs.version }}""`r`n";
        $innoVariables + (Get-Content ${{ env.Inno_Setup_Path }} -Raw) | Set-Content ${{ env.Inno_Setup_Tmp_Path }}
      
    - name: Build Setup.exe with Inno Setup
      uses: nadeemjazmawe/inno-setup-action-cli@v6.0.5
      with:
        filepath: ${{ env.Inno_Setup_Tmp_Path }}
      
    - name: Create or Update Release
      id: create_or_update_release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        $tag_name="${{ steps.get_version.outputs.version }}"
        $release_name="Release $tag_name"
        $prerelease="false"
        $draft="true"
        $apiHeaders=@{"Authorization"="Bearer $env:GITHUB_TOKEN"}
        $githubRepository=$env:GITHUB_REPOSITORY
        $getReleasesEndpoint="https://api.github.com/repos/$githubRepository/releases"
        
        # Cannot use the "Find Release by Tag" endpoint as it does not find draft releases.
        # Instead, getting all releases and manually filter by tag
        $result = Invoke-WebRequest -Headers $apiHeaders -SkipHttpErrorCheck -Uri $getReleasesEndpoint

        if ($result.StatusCode -ne 200)
        {
            echo "Invalid status code"
            echo $result
            exit 1
        }
        
        echo "Checking if release with tag $tag_name already exists"
        $findRelease = $result.Content | ConvertFrom-Json | Where-Object { $_.tag_name -eq $tag_name }
        
        if (!$findRelease)
        {
          echo "Release does not exist"
          echo "Creating new release as draft"
          $createReleaseEndpoint="https://api.github.com/repos/$githubRepository/releases"
          $postParams = @"
          { 
            "tag_name": "$tag_name",
            "name": "$release_name",
            "draft": $draft,
            "prerelease": $prerelease
          }
        "@
          $result = Invoke-WebRequest -Headers $apiHeaders -SkipHttpErrorCheck -Uri $createReleaseEndpoint -Method POST -Body $postParams
          if ($result.StatusCode -ne 201)
          {
            echo "Invalid status code"
            echo $result
            exit 1
          }
          echo "Release created"
          $resultAsJson = $result.Content  | ConvertFrom-Json 
          $uploadUrl = $resultAsJson.upload_url;
        }
        elseif (!$findRelease.draft)
        {
          echo "A release with tag $tag_name already exists and is not a draft"
          exit 1
        }
        else
        {
          $uploadUrl = $findRelease.upload_url;
          echo "Release already exists and is a draft version. Updating assets in the next build step."
        }
        echo "upload_url=$uploadUrl" >> $env:GITHUB_OUTPUT

    - name: Upload Setup.exe Release Asset
      uses: actions/upload-release-asset@v1
      with:
        upload_url: ${{ steps.create_or_update_release.outputs.upload_url }}
        asset_path: ./Deployment/Output/CommonScripts_Installer_${{ steps.get_version.outputs.version}}.exe
        asset_name: CommonScripts_Installer_${{ steps.get_version.outputs.version}}.exe
        asset_content_type: octet-stream
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload Published App Release Asset
      uses: actions/upload-release-asset@v1
      with:
        upload_url: ${{ steps.create_or_update_release.outputs.upload_url }}
        asset_path: ./app-publish.zip
        asset_name: App.zip
        asset_content_type: application/zip
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Update gist for AutoUpdater.NET
      id: update_gist_for_autoupdater
      env:
        GITHUB_TOKEN: ${{ secrets.GIST_GITHUB_TOKEN }}
        gistId: 484fa8d7871d44d1f67cc68a2c7d082f
        gistName: CommonScripts_LastVersion.xml
      run: |
        $tag_name="${{ steps.get_version.outputs.version }}"
        $apiHeaders=@{"Authorization"="Bearer $env:GITHUB_TOKEN"}
        $updateGistEndpoint="https://api.github.com/gists/$env:gistId"
        $gistContent = @"
        <?xml version="1.0" encoding="UTF-8"?>
        <item>
          <version>$tag_name</version>
          <url>https://github.com/yeray697/CommonScriptsContainer/releases/download/$tag_name/App.zip</url>
          <changelog>https://github.com/yeray697/CommonScriptsContainer/releases</changelog>
          <mandatory>false</mandatory>
        </item>
        "@
        $postParams = @{
          description = "XML for AutoUpdater.NET, used in CommonScriptsContainer application. Current version $tag_name";
          files       = @{
            $env:gistName = @{
              content = $gistContent
            }
          }
        }
        $postParams = $postParams | ConvertTo-Json -Depth 2
        $result = Invoke-WebRequest -Headers $apiHeaders -SkipHttpErrorCheck -Uri $updateGistEndpoint -Method POST -Body $postParams

        if ($result.StatusCode -ne 200)
        {
            echo "Invalid status code"
            echo $result
            exit 1
        }
        echo "Gist updated successfully"